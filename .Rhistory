phi = pars[12]
s = pars[7]
e = pars[8]
i = pars[9]
r = pars[10]
n = s+e+i+r
state <- c(S = s , E = e , I = i, R = r, N = n)
#Model representation
sir_rhs=function(t,state,pars){
with(as.list(c(state, pars)),{
#rates of change
dS <-  pars[1]*(1-pars[6]) -  (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12]))))  - pars[3]*S
dE <- (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12])))) - (pars[4]+pars[3])*E
dI <-  pars[4]*E - (pars[5]+pars[3])*I
dR <- pars[5]*I + (pars[1]*pars[6]) - pars[3]*R
dN <- pars[1] - pars[3]*N
# return the rate of change
return(list(c(dS, dE, dI, dR, dN)))
})
}
times <- seq(0, 37, by = 37/((469+1456)*7) )[1:((469+1456)*7)]
out <- ode(y = state, times = times, func = sir_rhs, parms = pars)
OUT<- report(out,gamma)
OUT = OUT[-(1:1456)]
data = Data
ESS = 0
error = data - OUT #assuming out[,2] is for incidence
ESS = sum(error^2)
return(ESS)
}
least_squares(pars,Data)
summary(Data)
head(Data)
library(deSolve)
require(pracma)
require(FME)
require(stats4)
require(bbmle)
Data = read.table(file.choose())
Data = Data[1:469,2]/5.1e+07
summary(Data)
head(Data)
report=function(out, gamma = gamma){
I= out[,4]
C=c()
for (i in 0:(468+1456) ){
C[i+1]=0
for (j in 1:7) {
x=(7*i)+j
C[i+1]=C[i+1] + gamma*I[x]*(1/(365.25*7))
}
}
return(C)
}
"MODEL"
pars <- c(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5)
pars <- as.vector(pars)
pars = as.vector(pars)
s = as.vector(pars[7])
e = as.vector(pars[8])
i = as.vector(pars[9])
r = as.vector(pars[10])
n = s+e+i+r
state <- c(S = s , E = e , I = i, R = r, N = n)
sir_rhs=function(t,state,pars){
with(as.list(c(state, pars)),{
#rates of change
dS <-  pars[1]*(1-pars[6]) -  (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12]))))  - pars[3]*S
dE <- (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12])))) - (pars[4]+pars[3])*E
dI <-  pars[4]*E - (pars[5]+pars[3])*I
dR <- pars[5]*I + (pars[1]*pars[6]) - pars[3]*R
dN <- pars[1] - pars[3]*N
# return the rate of change
return(list(c(dS, dE, dI, dR, dN)))
})
}
o = 37/((469+1456)*7)
times <- seq(0, 37, by = o)
times <- times[1:((469+1456)*7)] # 37 years in days  (length = 13475)
outt<- ode(y = state, times = times, func = sir_rhs, parms = pars)
plot(outt[,4])
least_squares=function(parameter, data){
pars <- as.vector(parameter)
mub=pars[1]
beta=pars[2]
mu = pars[3]
lambda = pars[4]
gamma = pars[5]
va =pars[6]
beta2 = pars[11]
phi = pars[12]
s = pars[7]
e = pars[8]
i = pars[9]
r = pars[10]
n = s+e+i+r
state <- c(S = s , E = e , I = i, R = r, N = n)
#Model representation
sir_rhs=function(t,state,pars){
with(as.list(c(state, pars)),{
#rates of change
dS <-  pars[1]*(1-pars[6]) -  (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12]))))  - pars[3]*S
dE <- (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12])))) - (pars[4]+pars[3])*E
dI <-  pars[4]*E - (pars[5]+pars[3])*I
dR <- pars[5]*I + (pars[1]*pars[6]) - pars[3]*R
dN <- pars[1] - pars[3]*N
# return the rate of change
return(list(c(dS, dE, dI, dR, dN)))
})
}
times <- seq(0, 37, by = 37/((469+1456)*7) )[1:((469+1456)*7)]
out <- ode(y = state, times = times, func = sir_rhs, parms = pars)
OUT<- report(out,gamma)
OUT = OUT[-(1:1456)]
data = Data
ESS = 0
error = data - OUT #assuming out[,2] is for incidence
ESS = sum(error^2)
return(ESS)
}
least_squares(pars,Data)
Model_fit=function(pars){
estpars<- fminsearch(least_squares, pars, minimize = TRUE, dfree = F,
maxiter = 10000, tol = .Machine$double.eps^(2/3))
return(estpars)
}
Newpars = Model_fit(pars)
Model_fit=function(pars){
estpars<- fminsearch(least_squares, pars, minimize = TRUE, dfree = F,
maxiter = 1e+5, tol = .Machine$double.xmin)
return(estpars)
}
Newpars = Model_fit(pars)
log_likelihood=function(mub,beta,mud,lambda,gamma,va,s,e,i,r, beta2, phi, mu, sigma){
pars <- c()
pars[5] = gamma
pars[1] = mub
pars[2] = beta
pars[3] = mud
pars[4] = lambda
gamma = pars[5]
pars[6] = va
pars[11] = beta2
pars[12] = phi
pars[7] =  s
pars[8] = e
pars[9] = i
pars[10] = r
n = s+e+i+r
state <- c(S = s , E = e , I = i, R = r, N = n)
#Model representation
sir_rhs=function(t,state,pars){
with(as.list(c(state, pars)),{
#rates of change
dS <-  pars[1]*(1-pars[6]) -  (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12]))))  - pars[3]*S
dE <- (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12])))) - (pars[4]+pars[3])*E
dI <-  pars[4]*E - (pars[5]+pars[3])*I
dR <- pars[5]*I + (pars[1]*pars[6]) - pars[3]*R
dN <- pars[1] - pars[3]*N
# return the rate of change
return(list(c(dS, dE, dI, dR, dN)))
})
}
times <- seq(0, 37, by = 37/((469+1456)*7) )[1:((469+1456)*7)]
out <- ode(y = state, times = times, func = sir_rhs, parms = pars)
OUT<- report(out,gamma)
OUT = OUT[-(1:1456)]
data = Data
Resd =  data - OUT #Residuals assumed with mean 0
R = suppressWarnings(dnorm(Resd , mu, sigma, log = T))
-sum(R)
}
fit = mle(log_likelihood, start = list(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5,  mu = 0, sigma = 3.637182)
, fixed = list(gamma = 365/14, mu = 0, va = 0), lower = rep(0,12),method = "L-BFGS-B" , nobs = 469)
fit = mle(log_likelihood, start = list(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5,  mu = 0, sigma = 3.637182)
, fixed = list(gamma = 365/14, mu = 0, va = 0), lower = rep(0,14), upper = rep(Inf,14),method = "L-BFGS-B" , nobs = 469)
fit = mle(log_likelihood, start = list(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5,  mu = 0, sigma = 3.637182)
, fixed = list(gamma = 365/14, mu = 0, va = 0), lower = rep(0,14), upper = rep(1000,14),method = "L-BFGS-B" , nobs = 469)
fit = mle(log_likelihood, start = list(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5,  mu = 0, sigma = 3.637182)
, fixed = list(gamma = 365/14, mu = 0, va = 0), lower = rep(0,14), upper = rep(1000,14),method = "BFGS" , nobs = 469)
fit = mle(log_likelihood, start = list(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5,  mu = 0, sigma = 3.637182)
, fixed = list(gamma = 365/14, mu = 0, va = 0), lower = rep(0,14), upper = rep(1000,14),method = "Brent" , nobs = 469)
fit = mle(log_likelihood, start = list(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5,  mu = 0, sigma = 3.637182)
, fixed = list(gamma = 365/14, mu = 0, va = 0), lower = rep(0,14), upper = rep(1000,14),method = "L-BFGS-B" , nobs = 469)
gamma = 365/14
pars <- c(mub=1/60, beta= 600, mud = 1/60, lambda = 365/8, gamma = 365/14,
va = 0, s = 1/23, e = 0, i = 1e-4, r = 1-1/23-1e-4 , beta2 = .2, phi = .5)
SEIRR<-function(pars){
pars = as.vector(pars)
#Initial Conditions
s = as.vector(pars[7])
e = as.vector(pars[8])
i = as.vector(pars[9])
r = as.vector(pars[10])
n = s+e+i+r
state <- c(S = s , E = e , I = i, R = r, N = n)
sir_rhs=function(t,state,pars){
with(as.list(c(state, pars)),{
#rates of change
dS <-  pars[1]*(1-pars[6]) -  (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12]))))  - pars[3]*S
dE <- (S*I*pars[2]*(1 + pars[11]*cos(2*pi*(t - pars[12])))) - (pars[4]+pars[3])*E
dI <-  pars[4]*E - (pars[5]+pars[3])*I
dR <- pars[5]*I + (pars[1]*pars[6]) - pars[3]*R
dN <- pars[1] - pars[3]*N
# return the rate of change
return(list(c(dS, dE, dI, dR, dN)))
})
}
times <- seq(0, 37, by = 37/((469+1456)*7) )[1:((469+1456)*7)]
out <- ode(y = state, times = times, func = sir_rhs, parms = pars)
new=as.data.frame(out)
time <- seq(0, 37, by = 37/((469+1456)*7) )[1:((469+1456)*7)]
timesD<- cbind(t=0:13474,time)
ii <- which (timesD[,1] %in% seq(0, 13474, by = 7))
Dat <- cbind(new[ii,], L=report(out,gamma))[-(1:1456),]
return(Dat)
}
out <- SEIRR(pars)
summary(out)
plot(out$I)
plot(out$L)
Fit <- modFit(f = SEIRRcost, p = pars, lower = rep(0,12), upper = c(rep(Inf,10),1,1)  )
SEIRRcost<- function(pars){
out<-SEIRR(pars)
cost <- modCost(model = out, obs = DataT)
return(cost)
}
Fit <- modFit(f = SEIRRcost, p = pars, lower = rep(0,12), upper = c(rep(Inf,10),1,1)  )
time <- seq(0, 37, by = 37/((469+1456)*7) )[1:((469+1456)*7)]
timesD<- cbind(t=0:13474,time)
ii <- which (timesD[,1] %in% seq(0, 13474, by = 7))[-(1:1456)]
DataT <- cbind(time = timesD[ii,2], L= Data) # Appending time and Data
SEIRRcost<- function(pars){
out<-SEIRR(pars)
cost <- modCost(model = out, obs = DataT)
return(cost)
}
Fit <- modFit(f = SEIRRcost, p = pars, lower = rep(0,12), upper = c(rep(Inf,10),1,1)  )
Sfun<-sensFun(func = SEIRR, parms = pars, senspar = c(1:6,11,12))
summary(Sfun)
plot(Sfun, which = c("L","S","E","I","R","N"), xlab ="time", lwd = 2)
ident <- collin(Sfun)
ident
ident
Fit <- modFit(f = SEIRRcost, p = pars, lower = rep(0,12), upper = c(rep(1000,10),1,1)  )
SEIRRcost(pars = )
SEIRRcost(pars)
t = seq(0,9, by = 9/(468))[1:(468)]
IData = read.table(file.choose())
IData = IData[2:469,2]
BData = read.table(file.choose())
BData = (BData[,2])/13 #Data is recorded quaterly, thus the resulting data is weekly
BData = rep(BData, each = 13)
plot(t,BData, type="l", col="blue")
plot(t,IData, type="l", col="red")
time = seq(0,9, by = 9/(226))[1:(226)]
NewData = cbind(IData,BData)
Biweekly=function(Data){
n=nrow(Data)/2
m=ncol(Data)
mat = matrix( ,n,m)
for (i in 0:n - 1 ){
mat[i + 1,]= rep(0, m)
for (j in 1:2) {
x = (2*i)+j
mat[i+1,] = c(mat[i+1,]) + c(Data[x,])
}
}
return(mat)
}
Cumulative = function(Data){
n=nrow(Data)
m=ncol(Data)
Dta=matrix( ,n,m)
Dta[1,] = Data[1,]
for (i in 2:n){
Dta[i,] = Dta[i-1,] + Data[i,]
}
return(Dta)
}
Fdat = Biweekly(NewData)# Biweekly data
sigmaU = 1
set.seed(143)
U = rnorm(226,0,sd=sigmaU)
Fdat.d = cbind(Fdat[-(227:234),1],Fdat[-(1:8),2],U) # Adjusting for the  delay caused by maternal immunity
Fdat1 = Cumulative(Fdat.d) # Cumulated table
NewData1 = cbind(Time=time,CIncidence=Fdat1[,1],CBirths=Fdat1[,2], U=Fdat1[,3])
NewData2 = as.data.frame(NewData1 )
head(NewData2)
fit <- lm(CBirths ~ CIncidence, data=NewData2)
summary(fit) # show results
plot(predict(fit)~CIncidence, data = NewData2)
confint(fit, level=0.95) # CIs for model parameters
anova(fit) # anova table
Resid.noisefree=as.vector(residuals(fit))# residuals
plot(Resid.noisefree~time, type="o", col="blue")
Resid.noise=as.vector(residuals(fit)) + NewData2$U # residuals with noise
plot(Resid.noise~time, type="o", col="blue")
fit.loess <- loess(CBirths ~ CIncidence, data=NewData2, degree = 1, span = 1.49992)
summary(fit.loess) # show results
Resid.loess=as.vector(fit.loess$residuals)+ NewData2$U# residuals
plot(Resid.loess~time, type="o", col="blue")
fit.loess$kd
require(locpol)# Package for estimating the parameters of local regression.
d <- data.frame(X = NewData2$CIncidence)
d$Y <- NewData2$CBirths
plot(d$X,d$Y)
sd = sqrt(var(d$X))
lpest1 <- locPolSmootherC(d$X,d$Y , d$X, bw = .225 * sd , deg = 1, gaussK)
lpest2 <- locpol(Y ~ X, data = d, bw = .225 * sd , kernel = gaussK, deg = 1, xeval = d$X)
lpest2$lpFit
lpest2$residuals
fitlp = lpest1$beta0 + lpest2$lpFit$Y1 * lpest2$lpFit[,1]
fitlm = fitted.values(fit)
mydat = data.frame(lpest2$lpFit[,1:2], b0=lpest1$beta0, b1=lpest2$lpFit$Y1,
fit=fitlp, resd=lpest2$residuals, fitlm)
Data = data.frame( Fdat.d[,-3], mydat )
Data[,9] = Data[,1] * Data[,6] #Creating I(t)
Data[,10] = c( NA, Data[,8])[1:226] #Creating Z(t-1)
Data[,11] = c( NA, Data[,9])[1:226] #Creating I(t-1)
colnames(Data)[c(1:2,8,9,10,11)] = c("C","B","Z","I","Zt-1","It-1")
source('~/GitHub/Measles/TSIR parameter estimation.R', echo=F)
Fitit(10)
sd
sd*.05
r = rep(NA,226)
rmod = 1:26
r[1:226] = rep( rmod , 9)[1:226]
r
source('~/GitHub/Measles/TSIR parameter estimation.R', echo=F)
Fitit(10)
log_lik = function(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67,dta = Data){
r = rep(NA,226)
r[1:226] = rep( rmod , 9)[1:226]
dta[1,10] = Z0
dta[1,11] = I0
Y = log(dta$I)
Ycap = log(r) + alpha1 * log(dta$`It-1`) + zeta * dta$`Zt-1`  # without error
Resd =  Y - Ycap #Residuals assumed with mean 0
R = suppressWarnings(dnorm(Resd , mu, sigma, log = T))
-sum(R)
}
fit = mle2(log_lik, start = list(alpha1 = 1, zeta = 1.573e-6, Z0 = -11259.898, I0 = 11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
require(bbmle)
fit = mle2(log_lik, start = list(alpha1 = 1, zeta = 1.573e-6, Z0 = -11259.898, I0 = 11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
log_lik()
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67,Dta=Data)
, fixed = list( mu = 0, Dta = Data) )
fit = mle2(log_li, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669, rmod = rep(1.349859,26), mu = 0, sigma = 57499.67,Dta=Data)
, fixed = list( mu = 0, Dta = Data) )
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,  mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
fit
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,rmod = rep(1.349859,26),  mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
log_lik = function(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,
rmod1,rmod2,rmod3,rmod4,rmod5,rmod6,rmod7,rmod8,rmod9,rmod10,rmod11,rmod12,rmod13,rmod14,rmod15,
rmod16,rmod17,rmod18,rmod19,rmod20,rmod21,rmod22,rmod23,rmod24,rmod25,rmod26, mu = 0, sigma = 57499.67,dta = Data){
r = rep(NA,226)
rmod = c(rmod1,rmod2,rmod3,rmod4,rmod5,rmod6,rmod7,rmod8,rmod9,rmod10,rmod11,rmod12,rmod13,rmod14,rmod15,
rmod16,rmod17,rmod18,rmod19,rmod20,rmod21,rmod22,rmod23,rmod24,rmod25,rmod26 )
r[1:226] = rep( rmod , 9)[1:226]
dta[1,10] = Z0
dta[1,11] = I0
Y = log(dta$I)
Ycap = log(r) + alpha1 * log(dta$`It-1`) + zeta * dta$`Zt-1`  # without error
Resd =  Y - Ycap #Residuals assumed with mean 0
R = suppressWarnings(dnorm(Resd , mu, sigma, log = T))
-sum(R)
}
require(bbmle)
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,
rmod1 = 1.3,rmod2= 1.3,rmod3= 1.3,rmod4= 1.3,rmod5= 1.3,rmod6= 1.3,rmod7= 1.3,rmod8= 1.3
,rmod9= 1.3,rmod10= 1.3,rmod11= 1.3,rmod12= 1.3,rmod13= 1.3,rmod14= 1.3,rmod15= 1.3,
rmod16= 1.3,rmod17= 1.3,rmod18= 1.3,rmod19= 1.3,rmod20= 1.3,rmod21= 1.3,rmod22= 1.3
,rmod23= 1.3,rmod24= 1.3,rmod25= 1.3,rmod26= 1.3
,  mu = 0, sigma = 57499.67)
, fixed = list( mu = 0) )
fit
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,
rmod1 = 1.3,rmod2= 1.3,rmod3= 1.3,rmod4= 1.3,rmod5= 1.3,rmod6= 1.3,rmod7= 1.3,rmod8= 1.3
,rmod9= 1.3,rmod10= 1.3,rmod11= 1.3,rmod12= 1.3,rmod13= 1.3,rmod14= 1.3,rmod15= 1.3,
rmod16= 1.3,rmod17= 1.3,rmod18= 1.3,rmod19= 1.3,rmod20= 1.3,rmod21= 1.3,rmod22= 1.3
,rmod23= 1.3,rmod24= 1.3,rmod25= 1.3,rmod26= 1.3
, sigma = 57499.67)
, fixed = list( mu = 0, Dta= Data) )
log_lik = function(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,
rmod1,rmod2,rmod3,rmod4,rmod5,rmod6,rmod7,rmod8,rmod9,rmod10,rmod11,rmod12,rmod13,rmod14,rmod15,
rmod16,rmod17,rmod18,rmod19,rmod20,rmod21,rmod22,rmod23,rmod24,rmod25,rmod26, mu = 0, sigma = 57499.67){
r = rep(NA,226)
rmod = c(rmod1,rmod2,rmod3,rmod4,rmod5,rmod6,rmod7,rmod8,rmod9,rmod10,rmod11,rmod12,rmod13,rmod14,rmod15,
rmod16,rmod17,rmod18,rmod19,rmod20,rmod21,rmod22,rmod23,rmod24,rmod25,rmod26 )
r[1:226] = rep( rmod , 9)[1:226]
dta =Data
dta[1,10] = Z0
dta[1,11] = I0
Y = log(dta$I)
Ycap = log(r) + alpha1 * log(dta$`It-1`) + zeta * dta$`Zt-1`  # without error
Resd =  Y - Ycap #Residuals assumed with mean 0
R = suppressWarnings(dnorm(Resd , mu, sigma, log = T))
-sum(R)
}
require(bbmle)
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,
rmod1 = 1.3,rmod2= 1.3,rmod3= 1.3,rmod4= 1.3,rmod5= 1.3,rmod6= 1.3,rmod7= 1.3,rmod8= 1.3
,rmod9= 1.3,rmod10= 1.3,rmod11= 1.3,rmod12= 1.3,rmod13= 1.3,rmod14= 1.3,rmod15= 1.3,
rmod16= 1.3,rmod17= 1.3,rmod18= 1.3,rmod19= 1.3,rmod20= 1.3,rmod21= 1.3,rmod22= 1.3
,rmod23= 1.3,rmod24= 1.3,rmod25= 1.3,rmod26= 1.3
, sigma = 57499.67)
, fixed = list( mu = 0) )
fit
fit = mle2(log_lik, start = list(alpha1 = 1, zeta =1.573e-6, Z0 = -11259.898, I0 =11389.669,
rmod1 = 1.2,rmod2= 1.3,rmod3= 1.33,rmod4= 1.35,rmod5= 1.3,rmod6= 1.3,rmod7= 1.3,rmod8= 1.3
,rmod9= 1.3,rmod10= 1.3,rmod11= 1.3,rmod12= 1.3,rmod13= 1.3,rmod14= 1.3,rmod15= 1.3,
rmod16= 1.3,rmod17= 1.3,rmod18= 1.3,rmod19= 1.3,rmod20= 1.3,rmod21= 1.3,rmod22= 1.3
,rmod23= 1.3,rmod24= 1.3,rmod25= 1.3,rmod26= 1.3
, sigma = 57499.67)
, fixed = list( mu = 0) )
fit
knitr::opts_chunk$set(echo = TRUE)
install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE)
t = seq(0,9, by = 9/(468))[1:(468)]
IData = read.table(file.choose())
IData = IData[2:469,2]
BData = read.table(file.choose())
BData = (BData[,2])/13 #Data is recorded quaterly, thus the resulting data is weekly
BData = rep(BData, each = 13)
plot(t,BData, type="l", col="blue")
plot(t,IData, type="l", col="red")
time = seq(0,9, by = 9/(226))[1:(226)]
#Bi-weekly dataset
NewData = cbind(IData,BData)
Biweekly=function(Data){
n=nrow(Data)/2
m=ncol(Data)
mat = matrix( ,n,m)
for (i in 0:n - 1 ){
mat[i + 1,]= rep(0, m)
for (j in 1:2) {
x = (2*i)+j
mat[i+1,] = c(mat[i+1,]) + c(Data[x,])
}
}
return(mat)
}
Cumulative = function(Data){
n=nrow(Data)
m=ncol(Data)
Dta=matrix( ,n,m)
Dta[1,] = Data[1,]
for (i in 2:n){
Dta[i,] = Dta[i-1,] + Data[i,]
}
return(Dta)
}
Fdat = Biweekly(NewData)
sigmaU = 1
set.seed(143)
U = rnorm(226,0,sd=sigmaU)
Fdat.d = cbind(Fdat[-(227:234),1],Fdat[-(1:8),2],U)
Fdat1 = Cumulative(Fdat.d) # Adjusting for the  delay caused by maternal immunity
NewData1 = cbind(Time=time,CIncidence=Fdat1[,1],CBirths=Fdat1[,2], U=Fdat1[,3])
NewData2 = as.data.frame(NewData1 )
head(NewData2)
fit <- lm(CBirths ~ CIncidence, data=NewData2)
summary(fit) # show results
plot(predict(fit)~CIncidence, data = NewData2)
confint(fit, level=0.95) # CIs for model parameters
anova(fit) # anova table
# covariance matrix for model parameters
# diagnostic plots
layout(matrix(c(1,2,3,4),2,2)) # optional 4 graphs/page
plot(fit)
Resid.noisefree=as.vector(residuals(fit))# residuals
plot(Resid.noisefree~time, type="o", col="blue")
Resid.noise=as.vector(residuals(fit)) + NewData2$U # residuals with noise
plot(Resid.noise~time, type="o", col="blue")
fit.loess <- loess(CBirths ~ CIncidence, data=NewData2, degree = 1, span = 1.49992)
summary(fit.loess) # show results
Resid.loess=as.vector(fit.loess$residuals)+ NewData2$U# residuals
plot(Resid.loess~time, type="o", col="blue")
fit.loess$kd
require(locpol)# Package for estimating the parameters of local regression.
d <- data.frame(x = NewData2$CIncidence)
d$y <- NewData2$CBirths
h <- denCVBwSelC(log(d$x), kernel = gaussK)
xeval <- log(d$x)
lpest1 <- locPolSmootherC(log(d$x),log(d$y) , xeval, bw = h , 1, gaussK)
mean(lpest1$beta1[-c(1,2)])
lpest1
plot(log(d$x),log(d$y))
attach(lpest1)
dev = beta1 * exp(beta0) * (x)^(beta1 - 1)
finalData = cbind(x, dev, Resid.loess)[-(1:2),]
tail(finalData)
finalData
install.packages("locpol")
require(locpol)
